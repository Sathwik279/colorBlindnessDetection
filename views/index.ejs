<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Model Viewer with Fullscreen and Improved Lighting</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      position: relative;
    }
    .canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
      width: 100%;
      max-width: 500px; /* Adjust as needed */
      height: auto;
    }
    .corner-buttons {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
      pointer-events: none;
    }
    .corner-buttons button, .corner-buttons input {
      pointer-events: auto;
      width: 50px;
      height: 50px;
      font-size: 12px;
      padding: 4px;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .small-btn {
      width: 50px;
      height: 50px;
      font-size: 10px;
      padding: 4px;
    }
  </style>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-purple-200 min-h-screen flex flex-col items-center justify-center p-4">
  <div class="canvas-container">
    <canvas
      id="leftEyeCanvas"
      class="bg-gray-200 shadow-lg rounded-xl border border-gray-300"
    ></canvas>
    <canvas
      id="rightEyeCanvas"
      class="bg-gray-200 shadow-lg rounded-xl border border-gray-300"
    ></canvas>
  </div>

  <div class="corner-buttons">
    <button
      id="fullscreen-btn"
      class="bg-blue-500 text-white small-btn shadow hover:bg-blue-600 transition-all"
      title="Fullscreen"
    >
      FS
    </button>

    <button
      id="signout"
      class="bg-red-500 text-white small-btn shadow hover:bg-red-600 transition-all"
      title="Sign Out"
    >
      SO
    </button>

    <input
      type="text"
      id="user-input"
      placeholder="Input"
      class="p-2 border border-gray-300 rounded-md shadow-sm text-center w-12"
      title="User Input"
    />

    <button
      id="next-btn"
      class="bg-blue-500 text-white small-btn shadow hover:bg-blue-600 transition-all"
      title="Next"
    >
      Next
    </button>

    <button
      id="submit-btn"
      style="display: none"
      class="bg-green-500 text-white small-btn shadow hover:bg-green-600 transition-all"
      title="Submit"
    >
      Sub
    </button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    const models = <%- JSON.stringify(models) %>;
    let userResponses = [];
    let currentIndex = 0;

    // Create scene and renderer
    const scene = new THREE.Scene();
    const leftCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const rightCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    const leftRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('leftEyeCanvas'), antialias: true });
    const rightRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('rightEyeCanvas'), antialias: true });

    leftRenderer.setSize(window.innerWidth / 2, window.innerHeight);
    rightRenderer.setSize(window.innerWidth / 2, window.innerHeight);

    scene.background = new THREE.Color(0xffffff);
    
    // Add lighting
    const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    scene.add(hemisphereLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5).normalize();
    scene.add(directionalLight);

    let currentModel = null;

    function loadModel(model) {
      const loader = new THREE.GLTFLoader();
      loader.load(model.path, (gltf) => {
        if (currentModel) {
          scene.remove(currentModel);
        }

        const model = gltf.scene;
        model.traverse((child) => {
          if (child.isMesh) {
            child.material.side = THREE.DoubleSide;
          }
        });

        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        const maxDimension = Math.max(size.x, size.y, size.z);

        const scale = Math.max(0.5, 1 / maxDimension);
        model.scale.set(scale, scale, scale);

        model.position.set(0, 0, 0);
        scene.add(model);
        currentModel = model;

        const center = box.getCenter(new THREE.Vector3());
        model.position.sub(center);

        // Set camera positions for left and right views
        leftCamera.position.set(-0.1, 0, Math.max(maxDimension * scale * 0.5, 3));
        rightCamera.position.set(0.1, 0, Math.max(maxDimension * scale * 0.5, 3));

        const animate = function () {
          leftRenderer.render(scene, leftCamera);
          rightRenderer.render(scene, rightCamera);
          requestAnimationFrame(animate);
        };
        animate();
      }, undefined, (error) => {
        console.error('An error occurred while loading the model:', error);
      });
    }

    function nextModel() {
      const inputField = document.getElementById("user-input");
      const userInput = inputField.value.trim();

      if (userInput) {
        userResponses[currentIndex] = {
          plateNo: models[currentIndex].plateNo,
          answer: userInput
        };
        inputField.value = "";
      }

      currentIndex++;

      if (currentIndex === models.length - 1) {
        document.getElementById("next-btn").style.display = "none";
        document.getElementById("submit-btn").style.display = "inline";
      }

      loadModel(models[currentIndex]);
    }

    function submitResponses() {
      const inputField = document.getElementById("user-input");
      const userInput = inputField.value.trim();

      if (userInput) {
        userResponses[currentIndex] = {
          plateNo: models[currentIndex].plateNo,
          answer: userInput
        };
        inputField.value = "";
      }

      fetch("/submit", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ responses: userResponses }),
      })
      .then((response) => response.json())
      .then((data) => {
        alert(`Blindness Type: ${data.blindnessType}, Intensity: ${data.intensity}`);
      })
      .catch((error) => console.error("Error submitting responses:", error));
    }

    const controls = new THREE.OrbitControls(leftCamera, leftRenderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;

    window.addEventListener("resize", () => {
      const width = window.innerWidth / 2;
      const height = window.innerHeight;
      leftRenderer.setSize(width, height);
      rightRenderer.setSize(width, height);
      leftCamera.aspect = width / height;
      rightCamera.aspect = width / height;
      leftCamera.updateProjectionMatrix();
      rightCamera.updateProjectionMatrix();
    });

    // Fullscreen functionality
    const fullscreenButton = document.getElementById("fullscreen-btn");

    fullscreenButton.addEventListener("click", () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        fullscreenButton.textContent = "Exit Fullscreen";
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
          fullscreenButton.textContent = "Enter Fullscreen";
        }
      }
    });

    // function handleOrientation(event) {
    //   const alpha = event.alpha ? THREE.Math.degToRad(event.alpha) : 0;
    //   const beta = event.beta ? THREE.Math.degToRad(event.beta) : 0;
    //   const gamma = event.gamma ? THREE.Math.degToRad(event.gamma) : 0;

    //   leftCamera.rotation.set(beta, alpha, -gamma);
    //   rightCamera.rotation.set(beta, alpha, -gamma);
    // }

    // window.addEventListener("deviceorientation", handleOrientation, true);
    
    // document.getElementById("next-btn").addEventListener("click", nextModel);
    // document.getElementById("submit-btn").addEventListener("click", submitResponses);

    loadModel(models[currentIndex]);
  </script>
</body>
</html>
